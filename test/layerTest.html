<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
</head>
<body>

<canvas id="c" width="500" height="500"></canvas>

<script src="https://cdn.rawgit.com/mrdoob/three.js/r71/build/three.min.js"></script>
<script src="../build/vox.js"></script>
<script>
    window.onload = function() {
        const updateListeners = [];
        const update = function (frame) {
            updateListeners.forEach(function (listener) {
                listener(frame);
            });
        };

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
        const cameraTarget = new THREE.Vector3(0, 10, 0);
        updateListeners.push(function(frame) {
            camera.position.x = Math.cos(frame * 0.004) * 50;
            camera.position.y = 15;
            camera.position.z = Math.sin(frame * 0.004) * 50;
            camera.lookAt(cameraTarget);
        });

        const directionalLight = new THREE.DirectionalLight(0xffffff);
        updateListeners.push(function(frame) {
            directionalLight.position.x = Math.cos(frame * -0.001) * 100;
            directionalLight.position.y = 100;
            directionalLight.position.z = Math.sin(frame * -0.001) * 100;
        });
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xaaaaaa);
        scene.add(ambientLight);

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById("c")
        });
        renderer.setSize(1024, 1024);
        renderer.setClearColor(0x000000);

        const parser = new vox.Parser();
        const parseTasks = [
            "vox/mv0.99.3/p20_p60.vox",
        ].map(function (path) {
            return parser.parse(path);
        });
        Promise
            .all(parseTasks)
            .then(function(voxelDataArray) {
                const setMesh = function(frameAttributes, currentNode) {
                    switch (currentNode.type) {
                        case 'transform':
                            const newFrameAttributes = frameAttributes.concat();
                            newFrameAttributes.push(currentNode.frameAttributes);
                            setMesh(newFrameAttributes, currentNode.childNode);
                            break;
                        case 'group':
                            currentNode.childNodes.forEach(function(node) {
                                setMesh(frameAttributes, node);
                            });
                            break;
                        case 'shape':
                            const builder = new vox.MeshBuilder(currentNode.modelAttributes, {
                                voxelSize: 1.0,
                                vertexColor: false,
                                optimizeFaces: true,
                            });
                            const mesh = builder.createMesh();

                            frameAttributes.forEach(function(attr) {
                                const rotation = getRotation(attr.rotation);

                                // TODO: 複数のrotationなどがくると上書きしてしまうので対応する
                                mesh.rotation.set(rotation.x, rotation.y, rotation.z);
                                mesh.position.set(attr.translation.x, attr.translation.y, attr.translation.z * -1);
                            });

                            scene.add(mesh);
                            break;
                    }
                };

                voxelDataArray.forEach(function(rootNode, i) {
                    rootNode.childNode.childNodes.forEach(function(node) {
                        setMesh([rootNode.frameAttributes], node);
                    });
                });
            });

        const getRotation = function(matrix) {
            let x, y, z = 0;
            switch (matrix[2][1]) {
                case -1:
                    x = - Math.PI / 2;
                    y = 0;
                    z = Math.atan2(matrix[1][0], matrix[0][0]);
                    break;
                case 1:
                    x = Math.PI / 2;
                    y = 0;
                    z = Math.atan2(matrix[1][0], matrix[0][0]);
                    break;
                default:
                    x = Math.asin(matrix[2][1]);
                    y = Math.atan2(- matrix[2][0], matrix[2][2]);
                    z = Math.atan2(- matrix[0][1], matrix[1][1]);
                    break;
            }

            return {
                x: x,
                y: z,
                z: y !== 0 ? y + Math.PI : y
            }
        };

        let frame = 0;
        const render = function () {
            update(frame++);
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        };
        render();
    };
</script>

</body>
</html>